.model small
.data
extrn key : byte
extrn keylen : word
extrn string : byte
.code
.486
public crypto
crypto proc
;local pr, c, j1, j2, j3, j4, j5, j6, t, endstr ;объявляем метки в макросе
lea si, string
xor bx, bx
pr:
cld             ;cброс флага направления
xor ax,ax
lodsb     ;загружаем в al символ по адресу si, увеличиваем si на 1
c:
	  cmp al,32       ;сравниваем с пробелом
	  jne j1          ;если не равен продолжаем сравнение
	  jmp pr          ;иначе пропускаем
j1:
    cmp al,44       ;сравниваем с запятой
	  jne j2          ;если не равен продолжаем сравнение
	  jmp pr          ;иначе пропускаем
j2:
    cmp al,59       ;сравниваем с точкой-запятой
  	jne j3          ;если не равен продолжаем сравнение
  	jmp pr          ;иначе пропускаем
j3:
    cmp al,13       ;сравниваем с символом возврата каретки
  	jne j4          ;если не равен продолжаем сравнение
  	jmp pr          ;иначе пропускаем
j4:
    cmp al,10       ;сравниваем с \n
  	jne j5          ;если не равен продолжаем сравнение
  	jmp pr          ;иначе пропускаем
j5:
    cmp al,'$'      ;сравниваем с концом строки
  	jne j6          ;если не равен обрабатываем
  	jmp endstr      ;иначе завершаем
j6:
    xor al,  key[bx] ;сумма по модулю 2 с ключом
    inc bx    ;увеличиваем счетчик ключа
    cmp bx, keylen ;проверяем длину
    jne t       ;если не равно продолжаем
    xor bx, bx  ;иначе обнуляем его
    t:
    mov di, si   ;берем адрес следущего символа
    dec di        ;уменьшаем на 1
    mov [di], al  ;заносим зашифрованный символ
jmp pr    ;повторяем пока не дойдем до конца строки
endstr:     ;выходим из макроса
ret
crypto endp
end
